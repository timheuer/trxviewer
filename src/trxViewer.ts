// Generated by Copilot
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as xml2js from 'xml2js';
import * as path from 'path';

interface TrxViewerContext {
    extensionUri?: vscode.Uri;
    cssUri?: vscode.Uri;
    scriptUri?: vscode.Uri;
    vscodeElementsCssUri?: vscode.Uri;
    codiconsUri?: vscode.Uri;
}

/**
 * View a TRX file in a webview panel
 */
export async function viewTrxFile(
    uri: vscode.Uri,
    context: TrxViewerContext,
    existingPanel?: vscode.WebviewPanel
): Promise<void> {
    try {
        // Verify file exists
        try {
            await vscode.workspace.fs.stat(uri);
        } catch (error) {
            throw new Error(`File not found: ${uri.fsPath}`);
        }

        // Read and validate TRX file content
        const trxContent = await fs.promises.readFile(uri.fsPath, 'utf-8');
        if (!trxContent.includes('<TestRun')) {
            throw new Error('Invalid TRX file: Missing TestRun element');
        }

        // Create or reuse the webview panel
        const panel = existingPanel || vscode.window.createWebviewPanel(
            'trxViewer',
            `TRX Viewer: ${path.basename(uri.fsPath)}`,
            vscode.ViewColumn.Beside,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: context.extensionUri ? [
                    context.extensionUri,
                    vscode.Uri.joinPath(context.extensionUri, 'node_modules', '@vscode')
                ] : []
            }
        );

        // Get the codicons URI
        const codiconsUri = panel.webview.asWebviewUri(
            vscode.Uri.joinPath(context.extensionUri!, 'node_modules', '@vscode', 'codicons', 'dist', 'codicon.css')
        );

        // Get paths to resources
        const webviewPath = path.join(context.extensionUri?.fsPath || '', 'src', 'webview');
        const cssUri = panel.webview.asWebviewUri(vscode.Uri.file(path.join(webviewPath, 'styles.css')));
        const vscodeElementsCssUri = panel.webview.asWebviewUri(vscode.Uri.file(path.join(webviewPath, 'vscode-elements.css')));
        const scriptUri = panel.webview.asWebviewUri(vscode.Uri.file(path.join(webviewPath, 'script.js')));
        const templatePath = path.join(webviewPath, 'template.html');

        // Parse and render TRX content
        const trxData = await parseTrxContent(trxContent);
        const templateContent = await fs.promises.readFile(templatePath, 'utf-8');
        const htmlContent = generateHtmlContent(templateContent, trxData, { cssUri, scriptUri, vscodeElementsCssUri, codiconsUri });
        panel.webview.html = htmlContent;

        // Handle webview messages
        panel.webview.onDidReceiveMessage(
            message => {
                switch (message.command) {
                    case 'error':
                        vscode.window.showErrorMessage(message.text);
                        return;
                    case 'info':
                        vscode.window.showInformationMessage(message.text);
                        return;
                }
            },
            undefined,
            context.extensionUri ? [] : undefined
        );

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        vscode.window.showErrorMessage(`Error opening TRX file: ${errorMessage}`, 'Show Details').then(selection => {
            if (selection === 'Show Details') {
                vscode.window.showErrorMessage(`Detailed error: ${errorMessage}\nFile: ${uri.fsPath}`, { modal: true });
            }
        });
        throw error;
    }
}

/**
 * Parse TRX content into a structured object
 */
async function parseTrxContent(content: string): Promise<any> {
    try {
        const parser = new xml2js.Parser({ explicitArray: false });
        return new Promise((resolve, reject) => {
            parser.parseString(content, (err: Error | null, result: any) => {
                if (err) {
                    reject(new Error(`Failed to parse TRX XML: ${err.message}`));
                } else {
                    resolve(normalizeTrxData(result));
                }
            });
        });
    } catch (error) {
        throw new Error(`Failed to parse TRX file: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Normalize and extract important data from the TRX structure
 */
function normalizeTrxData(data: any): any {
    const testRun = data.TestRun;
    if (!testRun) {
        throw new Error('Invalid TRX format: TestRun element not found');
    }

    const results = {
        testRun: {
            name: testRun.$.name || 'Unknown',
            runUser: testRun.$.runUser || 'Unknown',
            times: {
                start: testRun.Times?.$.start || '',
                finish: testRun.Times?.$.finish || ''
            },
            counters: extractCounters(testRun.ResultSummary?.Counters)
        },
        testDefinitions: extractTestDefinitions(testRun.TestDefinitions),
        testResults: extractTestResults(testRun.Results)
    };

    // Link test results with their definitions
    results.testResults = linkTestResultsWithDefinitions(results.testResults, results.testDefinitions);

    return results;
}

/**
 * Extract test counters from TRX data
 */
function extractCounters(counters: any): any {
    if (!counters || !counters.$) {
        return {
            total: '0',
            executed: '0',
            passed: '0',
            failed: '0',
            error: '0',
            timeout: '0',
            aborted: '0',
            inconclusive: '0',
            notExecuted: '0'
        };
    }

    return {
        total: counters.$.total || '0',
        executed: counters.$.executed || '0',
        passed: counters.$.passed || '0',
        failed: counters.$.failed || '0',
        error: counters.$.error || '0',
        timeout: counters.$.timeout || '0',
        aborted: counters.$.aborted || '0',
        inconclusive: counters.$.inconclusive || '0',
        passedButRunAborted: counters.$.passedButRunAborted || '0',
        notRunnable: counters.$.notRunnable || '0',
        notExecuted: counters.$.notExecuted || '0',
        disconnected: counters.$.disconnected || '0',
        warning: counters.$.warning || '0',
        completed: counters.$.completed || '0',
        inProgress: counters.$.inProgress || '0',
        pending: counters.$.pending || '0'
    };
}

/**
 * Extract test definitions from TRX data
 */
function extractTestDefinitions(testDefs: any): any[] {
    const definitions = [];
    if (!testDefs || !testDefs.UnitTest) {
        return [];
    }

    const unitTests = Array.isArray(testDefs.UnitTest)
        ? testDefs.UnitTest
        : [testDefs.UnitTest];

    for (const test of unitTests) {
        definitions.push({
            id: test.$.id || '',
            name: test.$.name || '',
            storage: test.TestMethod?.$.codeBase || '',
            className: test.TestMethod?.$.className || ''
        });
    }

    return definitions;
}

/**
 * Extract test results from TRX data
 */
function extractTestResults(results: any): any[] {
    const testResults = [];
    if (!results || !results.UnitTestResult) {
        return [];
    }

    const unitResults = Array.isArray(results.UnitTestResult)
        ? results.UnitTestResult
        : [results.UnitTestResult];

    for (const result of unitResults) {
        let errorInfo = null;
        if (result.Output?.ErrorInfo) {
            errorInfo = {
                message: result.Output.ErrorInfo.Message || '',
                stackTrace: result.Output.ErrorInfo.StackTrace || ''
            };
        }

        let output = null;
        if (result.Output?.StdOut) {
            output = result.Output.StdOut;
        }

        testResults.push({
            testId: result.$.testId || '',
            outcome: result.$.outcome || '',
            duration: result.$.duration || '',
            startTime: result.$.startTime || '',
            endTime: result.$.endTime || '',
            errorInfo,
            output
        });
    }

    return testResults;
}

/**
 * Link test results with their test definitions
 */
function linkTestResultsWithDefinitions(results: any[], definitions: any[]): any[] {
    return results.map(result => {
        const testDef = definitions.find(def => def.id === result.testId);
        return {
            ...result,
            name: testDef ? testDef.name : 'Unknown Test',
            className: testDef ? testDef.className : ''
        };
    });
}

/**
 * Format date string from TRX format to a more readable format
 */
function formatDate(dateStr: string): string {
    if (!dateStr) { return 'N/A'; }
    try {
        const date = new Date(dateStr);
        return date.toLocaleString();
    } catch (e) {
        return dateStr;
    }
}

interface HtmlResources {
    cssUri: vscode.Uri;
    scriptUri: vscode.Uri;
    vscodeElementsCssUri: vscode.Uri;
    codiconsUri: vscode.Uri;
}

/**
 * Generate HTML content by applying data to template
 */
function generateHtmlContent(template: string, data: any, resources: HtmlResources): string {
    const totalTests = parseInt(data.testRun.counters.total) || 0;
    const passedTests = parseInt(data.testRun.counters.passed) || 0;
    const failedTests = data.testResults.filter((t: any) => t.outcome === 'Failed');
    const passedTestResults = data.testResults.filter((t: any) => t.outcome === 'Passed');
    const otherTestResults = data.testResults.filter((t: any) => t.outcome !== 'Passed' && t.outcome !== 'Failed');
    const passPercentage = totalTests > 0 ? ((passedTests / totalTests) * 100).toFixed(2) : '0';

    // Add formatted dates to the template data
    const templateData = {
        ...data,
        testRun: {
            ...data.testRun,
            times: {
                ...data.testRun.times,
                startFormatted: formatDate(data.testRun.times.start),
                finishFormatted: formatDate(data.testRun.times.finish)
            }
        },
        passPercentage,
        failedCount: failedTests.length,
        passedCount: passedTestResults.length,
        otherCount: otherTestResults.length,
        failedTests: generateTestList(failedTests),
        passedTests: generateTestList(passedTestResults),
        otherTests: generateTestList(otherTestResults)
    };

    // Replace resource URIs and data placeholders
    let html = template
        .replace('{{cssUri}}', resources.cssUri.toString())
        .replace('{{scriptUri}}', resources.scriptUri.toString())
        .replace('{{vscodeElementsCssUri}}', resources.vscodeElementsCssUri.toString())
        .replace('{{codiconsUri}}', resources.codiconsUri.toString());

    // Replace all other template variables
    html = html.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
        const value = key.split('.').reduce((obj: any, k: string) => obj?.[k], templateData);
        return value ?? '';
    });

    return html;
}

/**
 * Generate HTML for a list of test results
 */
function generateTestList(tests: any[]): string {
    if (!tests || tests.length === 0) {
        return '<p>No tests found.</p>';
    }

    let html = '';
    for (const test of tests) {
        const testClass = test.outcome.toLowerCase();
        const testId = `test-${Math.random().toString(36).substr(2, 9)}`;
        const isFailedTest = test.outcome === 'Failed';

        html += `<div class="test-details">
            <details class="vscode-collapsible">
                <summary>
                    <i class="codicon codicon-chevron-right details-icon"></i>
                    <h2 class="title">
                        ${escapeHtmlAll(test.name)}
                    </h2>
                </summary>
                <div style="margin-left:0.5rem; margin-bottom:0.5rem">
                    <div>Class: ${escapeHtmlAll(test.className)}</div>
                    <div>Duration: <span class="duration">${formatDuration(test.duration)}</span></div>
                </div>`;

        if (test.errorInfo) {
            html += `
                <details class="vscode-collapsible sub">
                    <summary>
                        <i class="codicon codicon-chevron-right details-icon"></i>
                        <h2 class="title">
                            Error Details
                        </h2>
                    </summary>
                    <div style="margin-left:0.5rem">
                        <div class="error-message">${escapeHtmlPreserveLinks(test.errorInfo.message)}</div>
                        ${test.errorInfo.stackTrace ?
                    `<div class="stack-trace">${escapeHtmlPreserveLinks(test.errorInfo.stackTrace)}</div>` :
                    ''}
                    </div>
                </details>`;
        }

        if (test.output) {
            html += `
                <details class="vscode-collapsible sub">
                    <summary>
                        <i class="codicon codicon-chevron-right details-icon"></i>
                        <h2 class="title">
                            Output
                        </h2>
                    </summary>
                    <div style="margin-left:0.5rem">
                        <div class="test-output">${escapeHtmlPreserveLinks(test.output)}</div>
                    </div>
                </details>`;
        }

        html += `</details></div>`;
    }

    return html;
}

/**
 * Format duration from TRX format to a more readable format
 */
function formatDuration(durationStr: string): string {
    if (!durationStr) { return 'N/A'; }

    // If the duration is in the format "00:00:00.0000000"
    if (/^\d{2}:\d{2}:\d{2}/.test(durationStr)) {
        return durationStr;
    }

    // Otherwise, assume it's in the .NET TimeSpan format
    try {
        // TimeSpan format usually has the form "days.hours:minutes:seconds.fractional"
        // We'll try to parse it to milliseconds
        const matches = durationStr.match(/^(?:(\d+)\.)?(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?$/);
        if (!matches) { return durationStr; }

        const days = matches[1] ? parseInt(matches[1]) : 0;
        const hours = parseInt(matches[2]) + (days * 24);
        const minutes = parseInt(matches[3]);
        const seconds = parseInt(matches[4]);
        const ms = matches[5] ? parseInt(matches[5].substring(0, 3)) : 0;

        // Format the duration in a readable way
        if (hours > 0) {
            return `${hours}h ${minutes}m ${seconds}.${ms}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds}.${ms}s`;
        } else {
            return `${seconds}.${ms}s`;
        }
    } catch (e) {
        return durationStr;
    }
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
    if (!text) { return ''; }
    return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

/**
 * Escape HTML special characters and preserve URLs as clickable links
 */
function escapeHtmlPreserveLinks(text: string): string {
    if (!text) { return ''; }
    // First escape HTML
    const escaped = escapeHtml(text);

    // Then convert URLs to clickable links
    return escaped.replace(
        /(https?:\/\/[^\s<]+|www\.[^\s<]+\.[^\s<]+)/gi,
        (url) => `<a href="${url.startsWith('www.') ? 'http://' + url : url}" target="_blank">${url}</a>`
    );
}

/**
 * Escape HTML special characters and URLs without making them clickable
 */
function escapeHtmlAll(text: string): string {
    if (!text) { return ''; }
    return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;")
        .replace(/https?:\/\/[^\s<]+|www\.[^\s<]+\.[^\s<]+/gi, (url) => {
            return url.replace(/[:/.]/g, (char) => `&#${char.charCodeAt(0)};`);
        });
}